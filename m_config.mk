# This makefile manage the configuration related targets and variables.
# This file consider that the current project is based on Kconfig to
# manage its sources and configuration
# the config file is still '.config' and is sourced here.


# basic. The config file name is set here and _only_ here. Its existance is
# checked before including it
# for letter config check existance, the CONFIG_DONE var is tested
# (mandatory variable of the .confg file)
# PROJ_FILE is used to allow Makefiles in subdirs to source this file. They must
# set PROJ_FILE according to the source root directory, where both .config and
# config.mk are set

ifeq ("$(PROJ_FILES)","")
PROJ_FILES = ./
CONFIGFILE = .config
else
CONFIGFILE = $(PROJ_FILES)/.config
endif

# detect if the .config file exists, or just include... nothing
ifneq ("$(wildcard $(CONFIGFILE))","")
include $(CONFIGFILE)
endif

################################################################
# defining toolchain related values based on configuration
# This specify the toolchain binaries and prefixes
#
################################################################

# Variables defined with '?=' are overloadable by the shell
# environment variables or in the command line call.
#
# For e.g. you can execute:
# ADA_RUNTIME=/my/ada/toolchain/path CROSS_COMPILE=arm-eabi- make
#
# Remember that most of these variables can be set in the
# setenv.local.sh file (see setenv.sh fore more information)
#

# first, let's start with the basics (runtimes, prefixes...)


BOARDNAME     ?= $(CONFIG_BOARDNAME:"%"=%)
BOARDRELEASE  ?= $(CONFIG_BOARD_RELEASE:"%"=%)
ADAKERNEL     ?= $(CONFIG_ADAKERNEL)
ADA_RUNTIME   ?= $(ADA_RUNTIME:"%"=%)
CROSS_COMPILE ?= $(CROSS_COMPILE:"%"=%)
ARCH          ?= $(CONFIG_ARCH:"%"=%)
# defining target related options based on configuration
BOARD          = $(CONFIG_BOARDNAME:"%"=%)
SOC            = $(CONFIG_SOCNAME:"%"=%)
# Ada RTS (FIXME: to be integrated in KConfig)
RTS             = zfp-stp32f4




# in case .config is not set, to build kconfig-frontends in a given build_dir.
# this hack will be replaced by an external installation of kconfig-frontends
# instead of a local submodule
#
ifeq ("$(CONFIG_BUILD_DIR)","")
BUILD_DIR      = $(PROJ_FILES)/build/unconfigured
else
BUILD_DIR      = $(PROJ_FILES)$(CONFIG_BUILD_DIR:"%"=%)/$(ARCH)/$(BOARD)
PRIVATE_DIR    = $(PROJ_FILES)/$(CONFIG_PRIVATE_DIR:"%"=%)
endif




# Now, let's define the various toolchain standard variables
#
# for both native and cross toolchain, it is possible to override them
# with commandline-based variable if needed
# (e.g. CC= LD= make)
#
# first the cross-compilation toolchain
#
ifneq (y,$(USE_LLVM))
CROSS_CC       ?= $(CROSS_COMPILE)gcc
else
CROSS_CC       ?= $(CLANG_PATH)
endif

CROSS_LD       ?= $(CROSS_COMPILE)ld
CROSS_AR       ?= $(CROSS_COMPILE)ar
CROSS_ARFLAGS  ?= rcs
CROSS_OBJCOPY  ?= $(CROSS_COMPILE)objcopy
CROSS_GDB      ?= $(CROSS_COMPILE)gdb
CROSS_RANLIB   ?= $(CROSS_COMPILE)ranlib
#
# then the native toochain for native tools
#
ifneq (y,$(USE_LLVM))
CC             ?= gcc
else
CC             ?= $(CLANG_PATH)
endif

LD             ?= ld
AR             ?= ar
AS             ?= as
ARFLAGS        ?= rcs
OBJCOPY        ?= objcopy
GDB            ?= gdb
RANLIB         ?= ranlib
LIBTOOL        ?= libtool


RM             = rm
RMFLAGS       ?= -rf
TODEL          =
MKDIR          = mkdir -p
PWD            = $(shell pwd)



################################################################
# Compilation flags
# This compilation flags depends on the configuration as they
# may vary depending on the hardware target. They are generated
# in the global CFLAGS variable.
#
################################################################

# These flags are generated depending on the choosen toolchain
# (GCC or LLVM). They are integrated in a unified standard
# variable (CFLAGS).


# Replace this with proper Makefile substitution
# for GCC compilation
CFLAGS_GCC     := $(subst ",, $(CONFIG_AFLAGS_GCC))
CFLAGS_GCC     += $(subst ",, $(CONFIG_WARNFLAGS_GCC))
CFLAGS_GCC     += $(subst ",, $(CONFIG_DBGFLAGS_GCC))
CFLAGS_GCC     += $(subst ",, $(CONFIG_EMBEDCFLAGS))
CFLAGS_GCC     += $(subst ",, $(CONFIG_STACKPROTFLAGS))
AFLAGS_GCC  := $(subst ",, $(CONFIG_AFLAGS_GCC))


# for LLVM compilation
CFLAGS_LLVM    := $(subst ",, $(CONFIG_AFLAGS_LLVM))
CFLAGS_LLVM    += $(subst ",, $(CONFIG_WARNFLAGS_LLVM))
CFLAGS_LLVM    += $(subst ",, $(CONFIG_DBGFLAGS_LLVM))
CFLAGS_LLVM    += $(subst ",, $(CONFIG_EMBEDCFLAGS))
CFLAGS_LLVM    += $(subst ",, $(CONFIG_STACKPROTFLAGS))

AFLAGS_LLVM := $(subst ",, $(CONFIG_AFLAGS_LLVM))

ifneq (y,$(USE_LLVM))
CFLAGS         := $(CFLAGS_GCC)
AFLAGS      := $(AFLAGS_GCC)
else
CFLAGS         := $(CFLAGS_LLVM)
AFLAGS      := $(AFLAGS_LLVM)
endif

# Cflags for device autogenerated informations (based on the JSON layout)
# this layout should be used by drivers or for basics (e.g. leds) directly
# by applications, but *not* by libraries
CFLAGS_DRVLAYOUT  = "-I$(PROJ_FILES)/layouts/arch/socs/$(SOC)"

################################################################
# Modules-specific CFLAGS
# The SDK manages multiple modules, such as the kernel, userspace
# libraries, drivers, and so on.
# In order to simplify these modules Makefile, some CFLAGS are
# automatically generated. This is the case of the inclusion CFLAGS
# of all the activated libraries, drivers and so on. The goal is
# to allow an easy inclusion of these libraries headers without
# requiring multiple '-I...' integration in each libraries or
# applications Makefile.
#
# The following CFLAGS exists:
# LIB_CFLAGS      : including the path to all the activated libraries API
# DRIVERS_CFLAGS  : including the path to all the activated drivers API
# KERNEL_CFLAGS   : for the kernel, specific kernel-dedicated optimization
# APPS_CFLAGS     : all CFLAGS needed to compile applications (warnings,
#                   architecture, libraries, and so on...
# LIB_OPTIM_CFLAGS: library-specific optimization, if a differenciation
#                   is requested
#
################################################################



# kernel cflags
KERN_CFLAGS  = $(subst ",, $(CONFIG_KERN_CFLAGS)) -I$(PROJ_FILES)/include/generated $(CFLAGS)

# all userspace (lib, drv, applications) cflags
# for userspace only, GCC bug generating unaligned access
# on dynamic content which may lead to unaligned access
# hard fault. There is no dynamic content in the kernel.
USER_CFLAGS    = $(CFLAGS) -I$(PROJ_FILES) -I$(PROJ_FILES)/include/generated

# inclusion path for libraries
# This variable includes libraries api/ subdir for all libraries that are active in the configuration
LIB_INC_CFLAGS      = $(shell var=""; for i in `cat $(PROJ_FILES)/.config |grep "USR_LIB_.*CFLAGS"|cut -d'=' -f 2|cut -d' ' -f 2`; do var="$$var $$i"; done; echo $$var)

# inclusion path for drivers
# This variable includes drivers api/ subdir for all drivers that are active in the configuration
DRV_INC_CFLAGS    = $(shell var=""; for i in `cat $(PROJ_FILES)/.config |grep "USR_DRV_.*CFLAGS"|cut -d'=' -f 2|cut -d' ' -f 2`; do var="$$var $$i"; done; echo $$var)

# per userspace element cflag
# apps have access to both libs and drivers
APPS_CFLAGS    = $(USER_CFLAGS) $(LIB_INC_CFLAGS) $(DRV_INC_CFLAGS) $(CFLAGS_DRVLAYOUT)
# drivers have access to other drivers and to the libstd only
DRIVERS_CFLAGS = $(USER_CFLAGS) $(DRV_INC_CFLAGS) $(CFLAGS_DRVLAYOUT) -I$(PROJ_FILES)/libs/std/api
# libs have access to others libs and drivers
LIBS_CFLAGS    = $(USER_CFLAGS) $(LIB_INC_CFLAGS) $(DRV_INC_CFLAGS)



################################################################
# Link flags
# This link flags are the generic part of the linker flags.
# They permit a real separation of code and data in order to
# optimize a clear and efficient cleaning of unused functions
# when linking libraries and applications in a single ELF file.
#
################################################################

# this flag clean unused data/functions from firmware
# beware, it delete the allocator pool

LDFLAGS           = -fno-builtin -nostdlib -nodefaultlibs -nostartfiles
LDFLAGS          += -L$(BUILD_DIR)
ifneq ($(APP_BUILD_DIR),)
LDFLAGS          += -L$(APP_BUILD_DIR)
endif
# linking to libraries
LDFLAGS          += $(patsubst %, -L%, $(wildcard $(BUILD_DIR)/libs/lib*))
# linking to drivers
LDFLAGS          += $(patsubst %, -L%, $(wildcard $(BUILD_DIR)/drivers/lib*))
# linking to externals
LDFLAGS          += -L$(BUILD_DIR)/externals
# optimizing size
LDFLAGS          += --enable-objc-gc -Wl,--gc-sections


################################################################
# About externals
# For all external projects used in the SDK, associated configuration
# is set here.
#
################################################################


# About libecc
ECC_DIR        = $(PROJ_FILES)/$(subst ",,$(CONFIG_ECC_DIR))
ECC_CURVENAME  = $(CONFIG_ECC_CURVNAME:"%"=%)
# in case these vars doesn't exists yet
CONFIG_ECC_DIR?   = $(PROJ_FILES)libs/libecc

EC_UTILS          = $(BUILD_DIR)/tools/ec_utils


##### Handle the libsign CFLAGS
# We use SHA-256 and SHA-512 in various places in our embedded platform
LIBSIGN_CFLAGS = -MMD -MP -DWITH_LIBECC_CONFIG_OVERRIDE -DUSE_SIG_BLINDING -DWITH_HASH_SHA256 -DWITH_HASH_SHA512
# We are bound to use ECDSA as a signature algorithm because tokens lack support of other
# algorithms ...
LIBSIGN_CFLAGS += -DWITH_SIG_ECDSA
# The choice of the 256-bit curve is left to the user
ifeq ("$(CONFIG_ECC_CURVENAME_FR256)","y")
        LIBSIGN_CFLAGS += -DWITH_CURVE_FRP256V1
endif
ifeq ("$(CONFIG_ECC_CURVENAME_SP256)","y")
        LIBSIGN_CFLAGS += -DWITH_CURVE_SECP256R1
endif
ifeq ("$(CONFIG_ECC_CURVENAME_BP256)","y")
        LIBSIGN_CFLAGS += -DWITH_CURVE_BRAINPOOLP256R1
endif

KEYS_DIR       = $(PRIVATE_DIR)
KEYS_PREFIX    = $(CONFIG_PROJ_NAME:"%"=%)
KEYS_PATH      = $(KEYS_DIR)/$(KEYS_PREFIX)

# FIXME: should be replaced by a real external projects support
EXTERNAL_CFLAGS = -I$(PROJ_FILES)/libs/libecc/src


################################################################
# About Javacard
# All Javacard and applet specific configuration is set here.
#
################################################################


# About the tokens
AUTH_TOKEN_MAX_PIN  = $(CONFIG_AUTH_TOKEN_MAX_PIN:"%"=%)
AUTH_TOKEN_MAX_SC   = $(CONFIG_AUTH_TOKEN_MAX_SC:"%"=%)
AUTH_TOKEN_PET_PIN  = $(CONFIG_AUTH_TOKEN_PET_PIN:"%"=%)
AUTH_TOKEN_USER_PIN = $(CONFIG_AUTH_TOKEN_USER_PIN:"%"=%)
AUTH_TOKEN_PET_NAME = $(CONFIG_AUTH_TOKEN_PET_NAME:"%"=%)

DFU_TOKEN_MAX_PIN  = $(CONFIG_DFU_TOKEN_MAX_PIN:"%"=%)
DFU_TOKEN_MAX_SC   = $(CONFIG_DFU_TOKEN_MAX_SC:"%"=%)
DFU_TOKEN_PET_PIN  = $(CONFIG_DFU_TOKEN_PET_PIN:"%"=%)
DFU_TOKEN_USER_PIN = $(CONFIG_DFU_TOKEN_USER_PIN:"%"=%)
DFU_TOKEN_PET_NAME = $(CONFIG_DFU_TOKEN_PET_NAME:"%"=%)

USE_DIFFERENT_PHYSICAL_TOKENS = $(CONFIG_USE_DIFFERENT_PHYSICAL_TOKENS:"%"=%)

ifeq ("$(CONFIG_USE_SIG_TOKEN_BOOL)","y")
        USE_SIG_TOKEN = USE_SIG_TOKEN
        SIG_TOKEN_MAX_PIN  = $(CONFIG_SIG_TOKEN_MAX_PIN:"%"=%)
        SIG_TOKEN_MAX_SC   = $(CONFIG_SIG_TOKEN_MAX_SC:"%"=%)
        SIG_TOKEN_PET_PIN  = $(CONFIG_SIG_TOKEN_PET_PIN:"%"=%)
        SIG_TOKEN_USER_PIN = $(CONFIG_SIG_TOKEN_USER_PIN:"%"=%)
        SIG_TOKEN_PET_NAME = $(CONFIG_SIG_TOKEN_PET_NAME:"%"=%)
else
        USE_SIG_TOKEN = NO_SIG_TOKEN
        LOCAL_PASSWORD = $(CONFIG_LOCAL_PASSWORD:"%"=%)
endif

# export to all make call through environment
export ARCH CC AR LD OBJCOPY GDB RANLIB CROSS_COMPILE


TOKEN_KEYS_PATH=$(KEYS_DIR)/


# Token specific tools (signing, building, etc.)

KEY2HEADER = $(PROJ_FILES)/tools/key2header.py
KEY2JAVA = $(PROJ_FILES)/tools/key2java.py
GENKEYS = $(PROJ_FILES)/tools/gen_keys.py
SIGNFIRMWARE = $(PROJ_FILES)/tools/encrypt_sign_firmware.py
VERIFYFIRMWARE = $(PROJ_FILES)/tools/decrypt_verify_firmware.py


################################################################
# About Kconfig tooling
# Integration of the Kconfig tooling needed to support correctly
# the menuconfig and associated targets.
# This permit to detect which of the supported Kconfig parsers
# is installed on the host. These variables can be overloaded if
# you use another Kconfig parser not listed below, see the
# tataouine configuration part of the documentation for more
# information.
#
################################################################

# MCONF and CONF tools, generated by prepare_config
ifeq (, $(shell which kconfig-conf))
# here, we set potential new symbols (not set in current .config file)
# to their default value in the Kconfig file
#
# using python kconfiglib tool
MCONF            ?= menuconfig
CONF             ?= olddefconfig
CONF_ARGS        ?=
CONFGEN          ?= genconfig
CONFGEN_ARGS     ?= --header-path include/generated/autoconf.h
else
# using kconfig-frontend
MCONF            ?= kconfig-mconf
CONF             ?= kconfig-conf
CONF_ARGS        ?= --olddefconfig
CONFGEN          ?= true
CONFGEN_ARGS     ?=
endif

